h1. Writing Apache Handlers in Ruby with mod_ruby

This is a step-by-step for writing handlers in Ruby.


h2. mod_ruby Handler Types

Apache provides a number of hooks for customizing the way it deals with incoming requests, and mod_ruby provides Apache directives for hooking your Ruby code into many of these stages. You can hook mostly everything that the other Apache modules do, resulting in a huge amount of flexibility and control over your server.

This guide will cover each of the directives, explaining when it is called, and showing several examples of how it can be used.

There are also a few other directives to control the environment of the embedded Ruby; for documentation on those, see "Apache Directives":directives.


h2. Handlers

A handler is just a Ruby object of a certain duck-type that's registered with one or more Apache hooks; each hook expects that the object registered with it provides a particular method. Since Classes are Objects, too, handler methods can be (and often are) class methods. It's also completely acceptable (and useful) to register a single object for more than one hook.

Here are the hooks you can register handlers for with mod_ruby, in the order they're executed, along with the method you'll need to implement for a handler of that type:

!images/handler-order.png(Handler Order Diagram)!

h3. Handler Return Values

_To be done._


h3. ChildInitHandler

bc. def child_init( server_request )

_[ed: only tested in the prefork model; still need to test what happens in the other MPMs]_

The ChildInitHandler is a special handler that's invoked when an Apache child first starts up, once per child, which allows you to do any of the work that needs to be done before requests are able to be served. This is useful, for example, to establish connections to a database, set up any expensive data structures, or to load further dependencies.

Note that the @request@ argument that's given to the handler isn't a full @Apache::Request@, as there's no actual client request present, but it's populated with all of the server-global data.

Here's an example of establishing a database connection for each child which will later be available to the same handler object for all of the requests it handles.

This example requires the @pg@ gem, the Ruby PostgreSQL client library.

<notextile>
<pre class="brush:ruby">
#!/usr/bin/env ruby -wKU
#encoding: utf-8

# child_db_inithandler.rb

require 'pg'
require 'singleton'

class ChildDbInitHandler
    include Singleton

    ### Set up a database connection.
    def child_init( request )
        @conn = PGconn.connect( "host=localhost dbname=test" )
        request.server.log_info "Preconnect done: %p" % [ @conn ]
        return Apache::OK
    end

    ### Handle content, probably using the database connection.
    def handler( request )
        request.content_type = 'text/plain'
        request.puts "Database connection is: %p" % [ @conn ]
        return Apache::OK
    end

end
</pre>
</notextile>

It provides two methods, one for the @RubyChildInitHandler@ and one for the @RubyHandler@. The latter is just so we can see the database connection object later from the browser.

Since it's a @Singleton@, we can just refer to its @#instance@ to register it with the appropriate hooks.

When a new Apache child starts up, it will establish a connection to the database, and log that it's done so. This will happen before any client is handed off to it, ensuring that by the time it's handling a client request, the database connection is already ready and waiting. 

The Apache config for this will look something like:

<notextile>
<pre>
RubyRequire child_db_inithandler
RubyChildInitHandler ChildDbInitHandler.instance

<Location /child_init_preconnect>
	SetHandler ruby-object
	RubyHandler ChildDbInitHandler.instance
</Location>
</pre>
</notextile>

When the server starts up, you'll see log messages like:

<notextile>
<pre>
[Sat Nov 13 13:41:13 2010] [notice] Apache/2.2.15 (Unix) mod_ruby/1.3.0 Ruby/1.8.7(2009-06-12) configured -- resuming normal operations
[Sat Nov 13 13:41:13 2010] [info] Server built: Aug 24 2010 11:47:29
[Sat Nov 13 13:41:14 2010] [info] Preconnect done: #<PGconn:0x1013331d0>
[Sat Nov 13 13:41:14 2010] [info] Preconnect done: #<PGconn:0x1013331d0>
[Sat Nov 13 13:41:14 2010] [info] Preconnect done: #<PGconn:0x1013331d0>
[Sat Nov 13 13:41:14 2010] [info] Preconnect done: #<PGconn:0x1013331d0>
[Sat Nov 13 13:41:14 2010] [info] Preconnect done: #<PGconn:0x1013331d0>
</pre>
</notextile>

h3. PostReadRequestHandler

bc. def post_read_request( request )

The PostReadRequestHandler, as its name indicates, is invoked immediately after the request has been read and its headers parsed.

This handler is usually used to do some task which needs to be done once per request. 

An example of something you can do with a combination of the @PostReadRequestHandler@ and the @LogHandler@ (covered a little later) is to examine the effect on the resource consumption of the Apache child for each request. Resource usage statistics are gathered immediately before the request, and then compared with the amounts after the request is finished, and the results are logged.

The example requires the @rusage@ gem.

<notextile>
<pre>
#!/usr/bin/env ruby -wKU
#encoding: utf-8

# rusagelogger.rb

require 'singleton'
require 'rusage'

class RusageLogger
    include Singleton

	### Set up the handler's instance variables.
	def initialize
		@counter = 0
		@initial_usage = nil
	end


	######
	public
	######

    ### Set the initial usage right after the request is read.
    def post_read_request( request )
		# Only count the main request, not subrequests
		if request.main?
			@counter += 1
        	@initial_usage = Process.rusage
		end
        return Apache::DECLINED
    end

    ### Handle content, probably using the database connection.
    def log_transaction( request )
		if @initial_usage
			usage = Process.rusage

			maxrss_delta = usage.maxrss - @initial_usage.maxrss
			utime_delta  = usage.utime  - @initial_usage.utime
			stime_delta  = usage.stime  - @initial_usage.stime

			logmsg = "Usage deltas for child %d (after %d request/s): " %
				[ Process.pid, @counter ]
			logmsg << "rss: %0.1fKb, utime: %0.3f, stime: %0.3f" %
				[ maxrss_delta/1024.0, utime_delta, stime_delta ]

	        request.server.log_info( logmsg )
		end

        return Apache::DECLINED
    end

end
</pre>
</notextile>

You'd add this handler to your application like so:

<notextile>
<pre>
RubyRequire rubygems
RubyRequire rusagelogger
RubyPostReadRequestHandler RusageLogger.instance

<Location />
	...
	RubyLogHandler RusageLogger.instance
</Location>
</pre>
</notextile>

And the output might look something like:

<notextile>
<pre>
[Wed Dec 22 08:46:59 2010] [info] Usage deltas for child 57236 (after 1 request/s): \
	rss: 188.0Kb, utime: 0.001, stime: 0.001
[Wed Dec 22 08:47:27 2010] [info] Usage deltas for child 57238 (after 1 request/s): \
	rss: 168.0Kb, utime: 0.000, stime: 0.000
[Wed Dec 22 08:47:31 2010] [info] Usage deltas for child 57235 (after 2 request/s): \
	rss: 12.0Kb, utime: 0.000, stime: 0.000
[Wed Dec 22 08:47:40 2010] [info] Usage deltas for child 57236 (after 2 request/s): \
	rss: 24.0Kb, utime: 0.000, stime: 0.000
</pre>
</notextile>

Note that you can wrap this around any other Apache functionality, not just other Ruby handlers. 


h3. TransHandler

bc. def translate_uri( request )




h3. AccessHandler

bc. def check_access( request )


_To be done._

h3. TypeHandler

bc. def find_types( request )


_To be done._

h3. FixupHandler

bc. def fixup( request )


_To be done._

h3. RubyHandler:

bc. def handler( request )


_To be done._

h3. LogHandler

bc. def log_transaction( request )


_To be done._

h3. CleanupHandler

bc. def cleanup( request )


_To be done._

